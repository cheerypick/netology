<!DOCTYPE html>
<html lang="ru">
<head>
  <title>AngularJS</title>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="node_modules/shower-ribbon/styles/screen-16x10.css">
  <link rel="stylesheet" href="css/prism.css">
  <link rel="stylesheet" href="css/prism-fix.css">
  <link rel="stylesheet" href="css/netology.css">
</head>
<body class="shower list">
<header class="caption">
  <h1>Angular JS</h1>

  <p>Екатерина Орлова, Accenture</p>
</header>

<section class="slide" id="cover">
  <h2>AngularJS</h2>

  <p>
    <img src="i/dfitiskin.jpg" alt="" class="avatar">
    Екатерина Орлова <span class="position">Accenture</span>
  </p>
</section>
<section class="slide author" id="author">
  <img src="i/orlova.jpg" alt="">

  <h1>Екатерина Орлова</h1>

  <p class="position">Software developer, Accenture Norway</p>
  <ul class="contacts">
    <li><a href="mailto:ekaterina.orlova@gmail.com"><i class="fa fa-envelope-o" aria-hidden="true"></i>mailto:ekaterina.orlova@gmail.com</a>
    </li>
    <li><a href="skype:katerinaorlova?call"><i class="fa fa-skype" aria-hidden="true"></i>katerinaorlova</a></li>
    <li><a href="http://twitter.com/cheerypick"><i class="fa fa-twitter" aria-hidden="true"></i>@cheerypick</a></li>
  </ul>
</section>

<section class="slide" id="intro">
  <h2>Что такое Angular.js</h2>
  <ul>
    <li>Фреймворк для создания вебприложений (в первую очередь - Single Page Applications, SPA)
      с использованием шаблона MVC
    </li>
    <li>Декларативный подход вместо императивного</li>
    <li>"Если бы HTML был создан для создания приложений"</li>
  </ul>
</section>
<section class="slide" id="plus">
  <h2>ПЛЮСЫ</h2>
  <ul>
    <li>Быстрота и удобство разработки</li>
    <li>Быстрые, легко поддерживаемые и расширяемые приложения</li>
    <li>Удобство командной разработки</li>
  </ul>
</section>
<section class="slide" id="spa">
  <h2>SPA</h2>
  <ul>
    SPA
    <li>Выполняется на стороне клиента в Web-браузере</li>
    <li>Взаимодействует с сервером через AJAX-запросы (получая шаблоны и данные в ответ на запросы)</li>
    <li>Без полной перезагрузки страницы</li>
    <li>Примеры: Gmail, Soundcloud</li>
  </ul>
</section>


<section class="slide" id="spa-vs-mpa">
  <h2>SPA</h2>
  <img src="i/spavsmpa.PNG">

</section>


<section class="slide" id="mvc-pic">
  <h2>MVC</h2>

  <p>Model-view-controller (MVC, «модель-представление-контроллер», «модель-вид-контроллер»)
    — схема использования нескольких шаблонов проектирования, с помощью которых модель приложения,
    пользовательский интерфейс и взаимодействие с пользователем разделены на три отдельных компонента таким образом,
    чтобы модификация одного из компонентов оказывала минимальное воздействие на остальные.</p>
</section>

<section class="slide" id="mvc">
  <h2>MVC</h2>
  <ul>
    <li>Model - данные и методы работы с ними, БД</li>
    <li>View - отображение информации: UI, представление</li>
    <li>Controller - связь между пользователем и системой, между Model и View</li>
    <li>Angular - MV*: Model-View-Whatever</li>
  </ul>
  <img src="i/240px-MVC-Process.png">
</section>

<section class="slide" id="mvc-scheme">
  <h2>MVC</h2>
  <img src="i/MVC.png">

</section>

<section class="slide" id="mvc-angular">
  <h2>MVC</h2>
  <img src="i/f1d76d3dfd9d4f302beabb5df46e7b56.png">

</section>

<section class="slide" id="first-run">
  <h2>Установка и подключение</h2>
  <ul>
    <li>СDN</li>
    <li>Дистрибутив</li>
    <li>Менеджеры пакетов (bower, npm)</li>
  </ul>
</section>

<section class="slide" id="editor">
  <h2>Установка</h2>
  <img
    src="i/download.PNG">
</section>

<section class="slide" id="bootstrap">
  <h2>Как это работает</h2>

 <pre>
      <code class="language-html line-numbers">
        <xmp>
          <head>
            <script src="../libs/angular-1.5.3/angular.min.js">
            </script>
          </head>
          <body ng-app>
          <h1> {{'Hello, ' + 'world!'}}</h1>
          </body>
        </xmp>
      </code>
 </pre>
</section>

<section class="slide" id="how-it-works">
  <h2>Как это работает</h2>
  <ul>
    <li>Атрибут<code>ng-app</code> - это директива Angular</li>
    <li>Она отмечает HTML-элемент, который будет корневым элементом приложения.
    </li>
  </ul>
</section>


<section class="slide" id="directive">
  <h2>Директива</h2>
  <code>ng-repeat</code>
  <ul>
    <li>Oписывают изменение поведения или преобразование DOM</li>
    <li> множество встроенных и возможность написания собственных</li>
    <li>http://angular.ru/guide/directive</li>
  </ul>
</section>


<section class="slide" id="directives">
  <h2>Встроенные директивы</h2>
  <code> ng-app</code>

  <p>
    Корневой элемент angular приложения
  </p>
  <code>ng-bind</code>

  <p>
    Присваивает DOM-элементу значение выражения. Изменения переменной в scope приложения отражаются во view
  </p>
  <code>
    <xmp><span ng-bind="name"></span></xmp>
  </code>

</section>

<section class="slide" id="directives2">
  <h2>Встроенные директивы</h2>
  <code>ng-model</code>

  <p>
    Cхожа с ng-bind, устанавливает двустороннюю связь между view и model
  </p>
  <code>ng-class</code>

  <p>
    Динамическая загрузка и изменение атрибута class
  </p>
  <code>ng-controller</code>

  <p>
    Определяет JS controller class
  </p>
  <code>ng-repeat</code>

  <p>Итерация по коллекции, вывод элементов списка (самая мощная директива angular?)
  </p>

</section>

<section class="slide" id="directives3">
  <h2>Встроенные директивы</h2>
  <code>ng-show & ng-hide</code>

  <p>Отображение или скрытие элемента средствами CSS согласно условному выражению</p>
  <code>ng-if</code>

  <p>
    Схоже с ng-show/ng-hide, но элемент убирается из DOM, а при повторном появлении вставляется клон заново
    скомпилированного элемента</p>
  (Важно для быстродействия)

  <p>Так как атрибуты с префиксом ng-* - невалидный HTML, есть альтернатива: data-ng-*
  </p>

</section>

<section class="slide" id="expressions">
  <h2>Выражения</h2>
  <code>{{pokemon.name}}, {[1 + 2}}</code>
  <ul>
    <li>переменная, которая предварительно должна быть определена в контролере</li>
    <li>выражение (+, -, …)</li>
    <li><a
      href="http://angular-doc.herokuapp.com/guide/expression">http://angular-doc.herokuapp.com/guide/expression</a>
    </li>
  </ul>
</section>

<section class="slide" id="expressions2">
  <h2>Выражения Angular vs выражения JavaScript</h2>
  <ul>
    <li>значение всех свойств вычисляются в области видимости в отличие от JavaScript, где выражения
      вычисляются в глобальном window</li>
    <li>вычисление выражений лояльно к неопределенным и нулевым значениям, в отличие от JavaScript, где
      такие вычисления выдадут исключение NullPointerException</li>
    <li> последовательность действий не изменяется: в Angular нельзя использовать условные операторы, циклы и исключения</li>
    <li> фильтры: можно передать результат вычисления выражений через цепочку фильтров. Например, чтобы преобразовать
      объект даты в специфичный для данного региона понятный человеку формат.</li>
  </ul>
</section>


<section class="slide" id="roadmap">
  <h2>План занятия</h2>
  <ol class="double">
    <li><a href="#var"><code>var</code> и его грабли</a></li>
    <li><a href="#let">блочные переменные с <code>let</code> </a></li>
    <li><a href="#const">константы с <code>const</code></a></li>
    <li><a href="#arrow-func">стрелочные функции</a></li>
    <li><a href="#default-args">аргументы функции по умолчанию</a></li>
    <li><a href="#rest">объединение параметров</a></li>
    <li><a href="#spread">деструктуризация параметров</a></li>
    <li><a href="#destructuring">деструктуризация массивов и объектов</a></li>
    <li><a href="#object-literals">свойства и методы объектов</a></li>
    <li><a href="#class">Классы</a></li>
    <li><a href="#templates">Строковые шаблоны</a></li>
    <li><a href="#for-of">Цикл <code>for … of</code></a></li>
  </ol>
</section>

<section class="slide" id="var">
  <h2>Область видимости <code>var</code></h2>

  <p>Чему будет равна переменная <code>name</code>?</p>
    <pre>
      <code class="language-javascript line-numbers">
        function test() {
        var name = 'Мария';
        }

        test();
        console.log(name); // ???
      </code>
    </pre>
</section>
<section class="slide">
  <h2>За пределами функции переменная <code>var</code> не доступна</h2>
    <pre>
      <code class="language-javascript line-numbers">
        function test() {
        var name = 'Мария';
        }

        test();
        console.log(name); //
        <mark>undefined</mark>
      </code>
    </pre>
</section>
<section class="slide">
  <h2>Видна ли переменная <code>var</code> за пределами блока?</h2>
    <pre>
      <code class="language-javascript line-numbers">
        if (true) {
        var name = 'Мария';
        }

        console.log(name); // ???
      </code>
    </pre>
</section>
<section class="slide">
  <h2>Переменная доступна за пределеми блока в котором определена</h2>

  <p>Так как область видимости переменной объявленная через <code>var</code> функция, создание и обращение происходит в
    одной области видимости.</p>
    <pre>
      <code class="language-javascript line-numbers">
        if (true) {
        var name = 'Мария';
        }

        console.log(name); //
        <mark>Мария</mark>
      </code>
    </pre>
</section>
<section class="slide">
  <h2>Типичная ошибка с замыканиями</h2>
    <pre>
      <code class="language-javascript line-numbers">
        var imax = 4, i;
        for (var i = 0; i < imax; i++) {
        setTimeout(function () {
        console.log('Timeout %d finished', i + 1);
        }, 1000);
        }
      </code>
    </pre>
</section>
<section class="slide">
  <h2>Ожидаемый результат</h2>
    <pre>
      <code class="language-markup">
        > node test.js
        Timeout 1 finished
        Timeout 2 finished
        Timeout 3 finished
        Timeout 4 finished
        >
      </code>
    </pre>
</section>
<section class="slide">
  <h2>Фактический результат</h2>
    <pre>
      <code class="language-markup">
        > node test.js
        Timeout 5 finished
        Timeout 5 finished
        Timeout 5 finished
        Timeout 5 finished
        >
      </code>
    </pre>
</section>
<section class="slide">
  <h2>Проблема из-за области видимости переменной&nbsp;<code>i</code></h2>
  <ul>
    <li>Мы создаем в цикле 4 анонимные функции.</li>
    <li>Функции вызываются при наступлении события таймера.</li>
    <li>В функции есть замыкание на переменную <code>i</code>.</li>
    <li>У замкнутой переменной берется значение на момент вызова функции, а не на момент замыкания.</li>
    <li>Чему равна переменная <code>i</code> на момент срабатывания первого таймера?</li>
    <li>А чему она равна на момент выхода из цикла?</li>
  </ul>
</section>
<section class="slide">
  <h2>Как исправить типичную ошибку с замыканиями?</h2>
    <pre>
      <code class="language-javascript line-numbers">
        var imax = 4, i;
        for (var i = 0; i < imax; i++) {
        setTimeout(function () {
        console.log('Timeout %d finished', i + 1);
        }, 1000);
        }
        console.log(i + 1); //
        <mark>5</mark>
      </code>
    </pre>
</section>
<section class="slide">
  <h2>Вариант ES5: функция созданная и вызванная на лету</h2>
    <pre>
      <code class="language-javascript line-numbers">
        var imax = 4, i;
        for (var i = 0; i < imax; i++) {
        setTimeout(function (timer) {
        return function () {
        console.log('Timeout %d finished', timer);
        };
        }(i + 1), 1000);
        }
      </code>
    </pre>
</section>
<section class="slide">
  <h2>Вариант ES2015: переменная с блочной областью видимости</h2>
    <pre>
      <code class="language-javascript line-numbers">
        var imax = 4, i;
        for (var i = 0; i < imax; i++) {
        let timer = i + 1;
        setTimeout(function () {
        console.log('Timeout %d finished', timer);
        }, 1000);
        }
      </code>
    </pre>
</section>
<section class="slide">
  <h2>Почему пример с <code>let</code> работает?</h2>
  <ul>
    <li>Переменная объявленная через <code>let</code> имеет область видимости в рамках того блока в котором объявлена
      (от <code>{</code> до <code>}</code>).
    </li>
    <li>Значит переменная <code>timer</code> живет в рамках одной итерации цикла.</li>
    <li>Так как по окончании итерации область видимости очищается, текущее значение фиксируется в замыкании.</li>
    <li>Значение переменной больше никогда не меняется, так как доступ к ней остаётся только в замыкии.</li>
  </ul>
</section>

<section class="slide" id="let">
  <h2>Переменные объявленные через <code>let</code> живут только внутри блока между <code>{</code> и <code>}</code></h2>
    <pre>
      <code class="language-javascript line-numbers">
        let name = 'Иван';
        {
        let name = 'Мария';
        console.log(name); //
        <mark>Мария</mark>
        }
        console.log(name); //
        <mark>Иван</mark>
      </code>
    </pre>
</section>
<section class="slide">
  <h2>Аналогичный пример с <code>var</code> и функцией</h2>
    <pre>
      <code class="language-javascript line-numbers">
        var name = 'Иван';
        function () {
        var name = 'Мария';
        console.log(name); //
        <mark>Мария</mark>
        }();
        console.log(name); //
        <mark>Иван</mark>
      </code>
    </pre>
</section>
<section class="slide">
  <h2>Итератор <code>i</code> в цикле</h2>
    <pre>
      <code class="language-javascript line-numbers">
        let i = 99;
        for (let i = 0; i < 3; ++i) {
        console.log(i); //
        <mark>0, 1, 2</mark>
        }
        console.log(i); //
        <mark>99</mark>
      </code>
    </pre>
    <pre>
      <code class="language-javascript line-numbers">
        var i = 99;
        for (var i = 0; i < 3; ++i) {
        console.log(i); //
        <mark>0, 1, 2</mark>
        }
        console.log(i); //
        <mark>3</mark>
      </code>
    </pre>
</section>
<section class="slide">
  <h2>Объявления переменных не всплывают</h2>
    <pre>
      <code class="language-javascript line-numbers">
        console.log(name); //
        <mark class="important">ReferenceError: name is not defined</mark>
        let name = 'Иван';
      </code>
    </pre>
  <p>При обращении к блочной переменной до объявления возникает ошибка
    <mark class="important">ReferenceError: name is not defined</mark>
    .
  </p>
    <pre>
      <code class="language-javascript line-numbers">
        console.log(name); //
        <mark>undefined</mark>
        var name = 'Иван';
      </code>
    </pre>
  <p>До объявления ошибок не возникает. Но и значение не присвоено.</p>
</section>
<section class="slide">
  <h2><code>let</code> нельзя использовать вне блока кода в условиях</h2>
    <pre>
      <code class="language-javascript line-numbers">
        if (true)
        let name = 'Иван'; //
        <mark class="important">SyntaxError: Unexpected identifier</mark>
      </code>
    </pre>
  <p>Это приведет к синтаксической ошибке. Но если обернуть в фигурные скобки, то все ок:</p>
    <pre>
      <code class="language-javascript line-numbers">
        if (true) {
        let name = 'Иван';
        }
      </code>
    </pre>
</section>
<section class="slide">
  <h2>Особенности <code>let</code></h2>
  <ul>
    <li>Переменные объявленные через <code>let</code> живут только внутри блока между <code>{</code> и <code>}</code>.
    </li>
    <li>Определения цикла <code>for</code> относится к блоку тела цикла.</li>
    <li>Объявления переменных не всплывают.</li>
    <li><code>let</code> нельзя использовать вне блока кода в условиях.</li>
  </ul>
</section>

<section class="slide" id="const">
  <h2>Объявляем константы через <code>const</code></h2>
    <pre>
      <code class="language-javascript line-numbers">
        const name = 'Дима';
        name = 'Ольга'; //
        <mark class="important">TypeError: Assignment to constant variable.</mark>
      </code>
    </pre>
  <p>
    При попытке изменить константу возникает ошибка:
    <mark class="important">TypeError: Assignment to constant variable.</mark>
  </p>
</section>
<section class="slide">
  <h2><code>const</code> не «замораживает» объекты и массивы</h2>
    <pre>
      <code class="language-javascript line-numbers">
        const names = ['Дима', 'Олег', 'Роман'];
        names.push('Ольга');
        names.shift();
        names[1] = 'Рустэм';
        console.log(names.join(', ')); //
        <mark>Олег, Рустэм, Ольга</mark>
      </code>
    </pre>
  <p>
    При попытке изменить элементы массива или свойства объекта, добавить или удалить их, ошибок не возникает.
  </p>
</section>
<section class="slide">
  <h2>Перезапись переменной вызывает ошибку при любом типе данных</h2>
    <pre>
      <code class="language-javascript line-numbers">
        const names = ['Дима', 'Олег', 'Роман'];
        names = ['Джон', 'Джек', 'Бэн']; //
        <mark class="important">TypeError: Assignment to constant variable.</mark>
      </code>
    </pre>
    <pre>
      <code class="language-javascript line-numbers">
        const CONFIG = {
        host: 'netology.ru',
        port: 21
        }
        CONFIG.timeout = 24 * 60 * 60;
        CONFIG = 12; //
        <mark class="important">TypeError: Assignment to constant variable.</mark>
      </code>
    </pre>
</section>
<section class="slide">
  <h2>Константы объявленные через <code>const</code> тоже имеют блочную область видимости</h2>
    <pre>
      <code class="language-javascript line-numbers">
        const URL = 'http://netology.ru/';
        {
        const URL = 'http://ya.ru';
        }
        console.log(URL); //
        <mark>http://netology.ru/</mark>
      </code>
    </pre>
  <p>
    Для них характерны все особенности, характерные для <code>let</code>.
  </p>
</section>
<section class="slide">
  <h2>Особенности <code>const</code></h2>
  <ul>
    <li>При попытке изменить константу возникает ошибка.</li>
    <li><code>const</code> не «замораживает» объекты и массивы.</li>
    <li>При попытке перезаписать переменную возникает ошибка при любом типе данных.</li>
    <li>Константы объявленные через <code>const</code> тоже имеют блочную область видимости.</li>
  </ul>
</section>

<section class="slide" id="arrow-func">
  <h2>Функции-стрелки <code>=&gt;</code></h2>
    <pre>
      <code class="language-javascript line-numbers">
        var oddValues = [1, 2, 3, 4]
        .filter(
        <mark>function (number) {
          return number % 2;
          }
        </mark>
        );
        console.log(oddValues); // [1, 3]
      </code>
    </pre>
  <p>
    Тот же самый код с помощью функции-стрелки:
  </p>
    <pre>
      <code class="language-javascript line-numbers">
        var oddValues = [1, 2, 3, 4]
        .filter(
        <mark>number => number % 2</mark>
        );
        console.log(oddValues); // [1, 3]
      </code>
    </pre>
</section>
<section class="slide">
  <h2>Несколько аргументов</h2>

  <p>
    Заключаем блок аргументов в скобки:
  </p>
    <pre>
      <code class="language-javascript line-numbers">
        var oddKeys = [1, 2, 3, 4]
        .filter(
        <mark>(number, i)</mark>
        => i % 2);
        console.log(oddKeys); // [2, 4]
      </code>
    </pre>
  <p>
    Если аргументов нет, то указывать скобки обязательно:
  </p>
    <pre>
      <code class="language-javascript line-numbers">
        var allKeys = [1, 2, 3, 4]
        .filter(
        <mark>()</mark>
        => true);
        console.log(allKeys); // [1, 2, 3, 4]
      </code>
    </pre>
</section>
<section class="slide">
  <h2>Разширенное тело функции</h2>

  <p>
    Заключаем тело функции в фигурные скобки:
  </p>
    <pre>
      <code class="language-javascript line-numbers">
        var result = [1, 2, 3, 4].map((number, i) =>
        <mark>{
          if (i % 2 === 0) {
          return number * 10;
          }
          return number;
          }
        </mark>
        );
        console.log(result); // [10, 2, 30, 4]
      </code>
    </pre>
</section>
<section class="slide">
  <h2>Функции-стрелки можно создать и сохранить в переменную</h2>
    <pre>
      <code class="language-javascript line-numbers">
        var diff = (number, i) => {
        if (i % 2 === 0) {
        return number * 10;
        }
        return number;
        };
        var result = [1, 2, 3, 4].map(diff);
        console.log(result); // [10, 2, 30, 4]
      </code>
    </pre>
</section>
<section class="slide">
  <h2>Что будет выведено в консоль?</h2>
    <pre>
      <code class="language-javascript line-numbers">
        var user = {
        name: 'Иван',
        showNameDelay: function (delay) {
        setTimeout(function () {
        console.log(this.name);
        }, delay);
        }
        }
        user.showNameDelay(1000); //
        <mark>???</mark>
      </code>
    </pre>
</section>
<section class="slide">
  <h2>Это типичная ошибка с контекстом вызова</h2>
    <pre>
      <code class="language-javascript line-numbers">
        var user = {
        name: 'Иван',
        showNameDelay: function (delay) {
        setTimeout(function () {
        console.log(this.name);
        }, delay);
        }
        }
        user.showNameDelay(1000); //
        <mark class="important">undefined</mark>
      </code>
    </pre>
</section>
<section class="slide">
  <h2>ES5: сохранить <code>this</code> в переменную и использовать замыкание</h2>
    <pre>
      <code class="language-javascript line-numbers">
        var user = {
        name: 'Иван',
        showNameDelay: function (delay) {
        <mark>var self = this;</mark>
        setTimeout(function () {
        console.log(
        <mark>self.name</mark>
        );
        }, delay);
        }
        }
        user.showNameDelay(1000); //
        <mark class="important">Иван</mark>
      </code>
    </pre>
</section>
<section class="slide">
  <h2>Решение ES2015: использовать фунцию-стрелку</h2>

  <p>
    Фунции-стрелки не имеют собственного контекста вызова <code>this</code>, и используют текущий контекст:
  </p>
    <pre>
      <code class="language-javascript line-numbers">
        var user = {
        name: 'Иван',
        showNameDelay: function (delay) {
        setTimeout(
        <mark>() => console.log(this.name)</mark>
        , delay);
        }
        }
        user.showNameDelay(1000); //
        <mark class="important">Иван</mark>
      </code>
    </pre>
</section>
<section class="slide">
  <h2>Контекст фиксируется в момент создания и ничем его не изменить</h2>
    <pre>
      <code class="language-javascript line-numbers">
        var user = {
        name: 'Иван',
        getGreater: function () {
        return () => console.log('Привет, %s', this.name);
        }
        }
        var greater = user.getGreater();
        greater(); //
        <mark>Привет, Иван</mark>
        greater.call({ name: 'Мария' }); //
        <mark>Привет, Иван</mark>
      </code>
    </pre>
</section>
<section class="slide">
  <h2>Аналогично фиксируются аргументы</h2>
    <pre>
      <code class="language-javascript line-numbers">
        var user = {
        name: 'Иван',
        getGreater: function () {
        return () => console.log(
        <mark>arguments[0]</mark>
        , this.name);
        }
        }
        var greater = user.getGreater('%s, добрый день');
        var greater2 = greater.bind({ name: 'Наталья' });
        greater2('Прощай, %s'); //
        <mark>Иван, добрый день</mark>
        greater.apply({ name: 'Мария' }); //
        <mark>Иван, добрый день</mark>
      </code>
    </pre>
</section>
<section class="slide">
  <h2>Особенность функций-стрелок</h2>
  <ul>
    <li>Не имеют собственного контекста <code>this</code> и аргументов <code>arguments</code>, используют контекст и
      аргументы доступные на момент создания. По сути, действует как супер-<code>bind</code>.
    </li>
    <li>Более короткая запись<br><code>(аргумент1, аргумент2) => {код с return}</code>.</li>
    <li>Если аргумент всего один — его можно не брать в скобки.</li>
    <li>Если тело функции-стрелки простое выражение, то можно не писать фигурные скобки и <code>return</code>.</li>
  </ul>
</section>

<section class="slide" id="default-args">
  <h2>Значения по умолчанию аргументов функции</h2>
    <pre>
      <code class="language-javascript line-numbers">
        function greating(name = 'Гость') {
        console.log('Привет, %s', name);
        }

        greating(); //
        <mark>Привет, Гость</mark>
        greating(undefined); //
        <mark>Привет, Гость</mark>
        greating(null); //
        <mark>Привет, null</mark>
        greating('Иван'); //
        <mark>Привет, Иван</mark>
      </code>
    </pre>
</section>

<section class="slide">
  <h2>Возмедем все аргументы фунции в квадрат и вернем их массив</h2>
    <pre>
      <code class="language-javascript line-numbers">
        function sqr() {
        return arguments.map(i => i * i);
        }
        var result = sqr(2, 3, 4); //
        <mark class="important">TypeError: arguments.map is not a function</mark>
        console.log(result);
      </code>
    </pre>
  <p>
    Объект <code>arguments</code> — не является массивом и не имеет метода <code>map</code>.
  </p>
</section>
<section class="slide">
  <h2>Используем <code>map</code> из прототипа массива для <code>arguments</code>:</h2>
    <pre>
      <code class="language-javascript line-numbers">
        function sqr() {
        return Array.prototype.map
        .call(arguments, i => i * i);
        }
        var result = sqr(2, 3, 4);
        console.log(result); //
        <mark>[4, 9, 16]</mark>
      </code>
    </pre>
  <p>
    Теперь все работает. Но есть два недостатка. Во-первых, <code>arguments</code> нужно преобразовывать в массив или
    заимствовать методы массива. Во-вторых, не очевидно что функция вообще принимает параметры.
  </p>
</section>
<section class="slide" id="rest">
  <h2>Оператор объединения <code>…</code> позволяет собрать все аргументы функции в реальный массив</h2>
    <pre>
      <code class="language-javascript line-numbers">
        function sqr(
        <mark>...params</mark>
        ) {
        return params.map(i => i * i);
        }

        var result = sqr(2, 3, 4);
        console.log(result); //
        <mark>[4, 9, 16]</mark>
      </code>
    </pre>
  <p>
    В отличии от <code>arguments</code>, который массивом не является.
  </p>
</section>
<section class="slide">
  <h2>Оператор объединения <code>…</code> может быть использован только с последним аргументом</h2>
    <pre>
      <code class="language-javascript line-numbers">
        var multer = (multer, ...args) =>
        args.map(i => multer * i);
        var bad = (
        <mark class="important">...data</mark>
        , template) =>
        console.log(template, data.join('-'));
        //
        <mark class="important">SyntaxError: Rest parameter must be last formal parameter</mark>
      </code>
    </pre>
  <p>
    Если после объединения добавить еще аргумент, то возникнет синтаксическая ошибка
    <mark>SyntaxError: Rest parameter must be last formal parameter</mark>
  </p>
</section>

<section class="slide">
  <h2>Ищем максимум с использованием <code>apply</code></h2>
    <pre>
      <code class="language-javascript line-numbers">
        var numbers = [92, 13, 47, 120, 3, 69];
        var maxNumber = Math.max.apply(null, numbers);
        console.log(maxNumber); //
        <mark>120</mark>
      </code>
    </pre>
  <p>
    Если мы хотим передать в функцию с переменным числом аргументов массив, то единственный способ был использовать
    метод функции <code>apply</code>, который принимал вторым аргументом массив аргументов для вызываемой функции.
  </p>
</section>
<section class="slide" id="spread">
  <h2>Оператор деструктуризации <code>…</code> позволяет разбить массив и добавить как аргументы</h2>
    <pre>
      <code class="language-javascript line-numbers">
        var numbers = [92, 13, 47, 120, 3, 69];
        var maxNumber = Math.max(...numbers);
        console.log(maxNumber); //
        <mark>120</mark>
      </code>
    </pre>
  <p>
    Если после объединения добавить еще аргумент, то возникнет синтаксическая ошибка
    <mark>SyntaxError: Rest parameter must be last formal parameter</mark>
  </p>
</section>

<section class="slide" id="destructuring">
  <h2>Деструктуризация массивов</h2>

  <p>
    Используя оператор присвоения можно легко получить значения элементов массива в переменные:
  </p>
    <pre>
      <code class="language-javascript line-numbers">
        let info = ['Иван', 32, 'Уфа'];
        <mark>let [name, age, city] = info;</mark>
        console.log(name); // Иван
        console.log(age); // 32
        console.log(city); // Уфа
      </code>
    </pre>
</section>
<section class="slide">
  <h2>Деструктуризация объектов</h2>

  <p>
    Аналогично и с объектами. Если имена переменных совпадают с ключами:
  </p>
    <pre>
      <code class="language-javascript line-numbers">
        let info = { name: 'Иван', age: 32, city: 'Уфа' };
        <mark>let {name, age, city} = info;</mark>
        console.log(name, age, city); // Иван 32 Уфа
      </code>
    </pre>
</section>
<section class="slide">
  <h2>Деструктуризация объектов в переменные не совпадающие с ключами</h2>

  <p>
    Нужно указать ключи, и переменные через <code>:</code>. Все ключи объекта задействовать не обязательно:
  </p>
    <pre>
      <code class="language-javascript line-numbers">
        let info = { name: 'Иван', age: 32, city: 'Уфа' };
        <mark>let { name: userName, city: location } = info;</mark>
        console.log(userName); // Иван
        console.log(location); // Уфа
      </code>
    </pre>
</section>
<section class="slide">
  <h2>Выбираем некоторые элементы массива</h2>

  <p>
    Можно пропускать элементы, и использовать оператор объединения:
  </p>
    <pre>
      <code class="language-javascript line-numbers">
        let numbers = [1, 2, 3, 4, 5, 6];
        let [one
        <mark>,,,</mark>
        four,
        <mark>...other</mark>
        ] = numbers;
        console.log(one); // 1
        console.log(four); // 4
        console.log(other); // [5, 6]
      </code>
    </pre>
</section>

<section class="slide" id="object-literals">
  <h2>Создание свойств из переменных</h2>
    <pre>
      <code class="language-javascript line-numbers">
        let name = 'Николай', age = 21;
        let user = { name, age, city: 'Москва' };
        console.log(user.name); //
        <mark>Николай</mark>
        console.log(user.age); //
        <mark>21</mark>
      </code>
    </pre>
  <p>
    Ранее это нужно было записывать так:
  </p>
    <pre>
      <code class="language-javascript line-numbers">
        let name = 'Николай', age = 21;
        let user = {
        <mark>name: name, age: age</mark>
        , city: 'Москва' };
      </code>
    </pre>
</section>
<section class="slide">
  <h2>Возможность определить имена свойств выражением</h2>
    <pre>
      <code class="language-javascript line-numbers">
        let key = 'Location', value = 'Волгоград';
        let user = {
        name: 'Мария',
        <mark>[key.toLowerCase()]</mark>
        : value,
        <mark>['user' + key]</mark>
        : value
        };
        console.log(user['location']); //
        <mark>Волгоград</mark>
        console.log(user.userLocation); //
        <mark>Волгоград</mark>
      </code>
    </pre>
</section>
<section class="slide">
  <h2>Короткая запись для методов</h2>
    <pre>
      <code class="language-javascript line-numbers">
        var user = {
        name: 'Иван',
        show() {
        console.log(this.name);
        }
        }

        user.show(); //
        <mark>Иван</mark>
      </code>
    </pre>
</section>
<section class="slide">
  <h2>Короткая запись для геттеров и сеттеров</h2>
    <pre>
      <code class="language-javascript line-numbers">
        var user = {
        name: 'Иван',
        yob: 1987,
        <mark>set age(age)</mark>
        {
        const now = new Date();
        this.yob = now.getFullYear() - age;
        },
        }
        user.age = 67;
        console.log(user.yob); //
        <mark>1949</mark>
      </code>
    </pre>
</section>

<section class="slide" id="class">
  <h2>Синтаксический сахар: создание классов</h2>
    <pre>
      <code class="language-javascript line-numbers">
        class Shape {
        constructor(x, y) {
        this.x = x;
        this.y = y;
        }
        move(dx = 0, dy = 0) {
        this.x += dx;
        this.y += dy;
        }
        }
      </code>
    </pre>
</section>
<section class="slide">
  <h2>Классы в ES2015 это просто другая форма записи</h2>

  <p>
    Этот код эквивалентен примеру с <code>class</code>.
  </p>
    <pre>
      <code class="language-javascript line-numbers">
        function Shape(x, y) {
        this.x = x;
        this.y = y;
        }
        Shape.prototype.move = function (dx, dy) {
        this.x += dx;
        this.y += dy;
        }
      </code>
    </pre>
</section>
<section class="slide">
  <h2>Наследование классов с использованием <code>extends</code> и <code>super</code></h2>
    <pre>
      <code class="language-javascript line-numbers">
        class Circle extends Shape {
        constructor(x, y, radius) {
        super(x, y);
        this.raduis = radius;
        }
        }

        let item = new Circle(50, 50, 30);
        item.move(10, 10);
      </code>
    </pre>
</section>
<section class="slide">
  <h2>Опять же это просто прототипное наследование как и раньше</h2>

  <p>
    Этот код эквивалентен примеру с <code>class</code>.
  </p>
    <pre>
      <code class="language-javascript line-numbers">
        function Cirle(x, y, radius) {
        Shape.call(this, x, y);
        this.raduis = radius;
        }
        Cirle.prototype = Object.create(Shape.prototype);
        Cirle.prototype.constructor = Cirle;
      </code>
    </pre>
</section>

<section class="slide" id="templates">
  <h2>Строковые шаблоны</h2>

  <p>
    С использованием кавычек <code>``</code> теперь можно подставлять значения переменных в строки.
  </p>
    <pre>
      <code class="language-javascript line-numbers">
        var name = 'Георгий', email = 'georg@test.co';
        console.log(`Привет, ${name}! Чем могу помочь?`);
        console.log(`Письмо отправлено по адресу ${email}.`);
      </code>
    </pre>
</section>

<section class="slide" id="for-of">
  <h2>Перебор итерируемых элементов с помощью <code>for … of</code></h2>
    <pre>
      <code class="language-javascript line-numbers">
        const names = ['Борис', 'Олег', 'Никита'];
        names._hiddenParam = 42;
        for (let name of names) {
        console.log(
        <mark>name</mark>
        ); // Борис, Олег, Никита
        }
        for (let i in names) {
        console.log(
        <mark>names[i]</mark>
        ); // Борис, Олег, Никита,
        <mark class="important">42</mark>
        }
      </code>
    </pre>
</section>

<section class="slide" id="resources">
  <h2>Материалы</h2>
  <ul>
    <li>AngularJS официальный tutorial <a
      href="https://docs.angularjs.org/tutorial">https://docs.angularjs.org/tutorial</a>.
    </li>
    <li>Раздел <a href="https://learn.javascript.ru/es-modern">Современные возможности ES-2015</a> в учебнике на
      javascript.ru
    </li>
    <li>Статья <a href="https://github.com/metagrover/ES6-for-humans">ES6 простым человеческим языком</a> и её <a
      href="https://habrahabr.ru/post/305900/">перевод на хабре</a>.
    </li>
    <li>Серия статей <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">ES6 изнутри</a> и их <a
      href="http://css-live.ru/?s=es6%3A&searchsubmit=U">перевод на css-live.ru</a>.
    </li>
  </ul>
</section>

<section class="slide" id="homework">
  <h2>Домашнее задание — часть 1</h2>

  <p>
    В задании необходимо использовать возможности ES2015 по максимуму.
  </p>
  <ul>
    <li>Создать класс <code>Pokemon</code>, конструктор которого принимает имя и уровень в качестве аргумента. Все
      экземпляры этого класса должны иметь общий метод <code>show</code>, который выводит информацию о покемоне.
    </li>
    <li>Создать класс <code>PokemonList</code>, который в качестве аргументов принимает любое количество покемонов.
      Экземпляры этого класса должны обладать всеми функциями массива. А так же иметь метод <code>add</code>, который
      принимает в качестве аргументов имя и уровень, создает нового покемона и добавляет его в список.
    </li>
  </ul>
</section>
<section class="slide">
  <h2>Домашнее задание — часть 2</h2>
  <ul>
    <li>Создать два списка покемонов и сохранить их в переменных <code>lost</code> и <code>found</code>. Имена и уровни
      придумайте самостоятельно.
    </li>
    <li>Добавить несколько новых покемонов в каждый список.</li>
    <li>Добавить спискам покемонов метод <code>show</code>, который выводит информацию о покемонах и их общее количество
      в списке.
    </li>
    <li>Перевести одного из покемонов из списка <code>lost</code> в список <code>found</code></li>
  </ul>
</section>
<section class="slide">
  <h2>Домашнее задание — на зачет с отличием</h2>
  <ul>
    <li>Добавить спискам покемонов метод <code>max</code>, который возвращает покемона максимального уровня.</li>
    <li>Переопределите и используйте метод <code>valueOf</code> у покемонов, для решения этой задачи.</li>
  </ul>
</section>
<section class="slide">
  <h2>Как предоставить код домашней работы на проверку</h2>

  <p>
    Способы предоставить домашнее задание в порядке приоритета:
  </p>
  <ol>
    <li>Исходный код на <a href="https://bitbucket.org/">BitBucket</a> или <a href="https://github.com/">GitHub</a></li>
    <li>Код в <a href="http://codepen.io/">CodePen</a> или <a href="https://jsfiddle.net/">JSFiddle</a></li>
  </ol>
</section>

<section class="slide last">
  <p class="thanx">Задавайте вопросы и напишите отзыв о лекции!</p>
  <address>Екатерина Орлова</address>
  <ul class="contacts">
    <li><a href="mailto:ekaterina.orlova@gmail.com"><i class="fa fa-envelope-o" aria-hidden="true"></i>ekaterina.orlova@gmail.com</a>
    </li>
    <li><a href="skype:katerinaorlova?call"><i class="fa fa-skype" aria-hidden="true"></i>katerinaorlova</a></li>
  </ul>
</section>


<div class="progress"></div>
<script src="node_modules/shower-core/shower.min.js"></script>
<script src="js/prism.js?v=2"></script>
<script src="https://use.fontawesome.com/30b5a52164.js"></script>
</body>
</html>
